--- a/scripts/pdf-smoke-test.ts
+++ b/scripts/pdf-smoke-test.ts
@@ -40,9 +40,26 @@ function safeName(input: string): string {
 async function runSmokeTest() {
   let browser: any = null
   let page: any = null
+  let label = 'unknown'
 
   try {
     console.log('üîç Starting PDF smoke test...')
-    console.log(`üìç URL: ${PRINT_URL.replace(/\?token=[^&]+/, '?token=***')}`)
+    
+    // Prepare output directory
+    fs.mkdirSync(OUT_DIR, { recursive: true })
+    
+    // Generate label for screenshots
+    const urlObj = new URL(PRINT_URL)
+    const runId = urlObj.pathname.split('/').pop() || 'unknown_run'
+    label = safeName(process.env.PACKET_LABEL || runId)
+    
+    // Prepare final URL with token if needed
+    let finalUrl = PRINT_URL
+    if (PRINT_TOKEN && !/[\?&]token=/.test(PRINT_URL)) {
+      const u = new URL(PRINT_URL)
+      u.searchParams.set('token', PRINT_TOKEN)
+      finalUrl = u.toString()
+    }
+    
+    console.log(`üìç URL: ${finalUrl.replace(/\?token=[^&]+/, '?token=***')}`)
+    console.log(`üìÅ Output directory: ${OUT_DIR}`)
+    console.log(`üè∑Ô∏è  Label: ${label}`)
 
     // Launch browser
     browser = await chromium.launch({
@@ -55,7 +72,18 @@ async function runSmokeTest() {
     await page.setViewportSize({ width: 1200, height: 1600 })
 
     // Navigate to print URL
     console.log('üìÑ Loading print page...')
-    const response = await page.goto(PRINT_URL, {
+    let response
+    let retries = 2
+    while (retries >= 0) {
+      try {
+        response = await page.goto(finalUrl, {
+          waitUntil: 'networkidle',
+          timeout: 30000,
+        })
+        break
+      } catch (err: any) {
+        if (retries > 0) {
+          console.log(`‚ö†Ô∏è  Navigation failed, retrying... (${retries} attempts left)`)
+          retries--
+          await new Promise(resolve => setTimeout(resolve, 2000))
+        } else {
+          throw err
+        }
+      }
+    }
+
+    if (!response || response.status() !== 200) {
+      throw new Error(`Failed to load page: HTTP ${response?.status()}`)
+    }
+
+    console.log('‚úÖ Page loaded successfully')
+
+    // Wait for PDF ready marker (critical - PDF service waits for this)
+    console.log('‚è≥ Waiting for PDF ready marker (#pdf-ready[data-ready="1"])...')
+    try {
+      await page.waitForSelector('#pdf-ready[data-ready="1"]', {
+        timeout: 15000,
+      })
+      console.log('‚úÖ PDF ready marker found')
+    } catch (error) {
+      // Retry once for flaky headless
+      console.log('‚ö†Ô∏è  Marker not found immediately, retrying...')
+      try {
+        await page.waitForSelector('#pdf-ready[data-ready="1"]', {
+          timeout: 10000,
+        })
+        console.log('‚úÖ PDF ready marker found on retry')
+      } catch (retryError) {
+        throw new Error('PDF ready marker not found - PDF service will hang!')
+      }
+    }
+
+    // Verify key selectors exist
+    console.log('üîç Verifying page structure...')
+    const checks = [
+      { selector: '.cover-page', name: 'Cover page' },
+      { selector: '.section-header, .section-title', name: 'Section headers' },
+      { selector: 'body[data-organization-name]', name: 'Organization metadata' },
+      { selector: 'body[data-job-id]', name: 'Job ID metadata' },
+      { selector: 'body[data-run-id]', name: 'Run ID metadata' },
+    ]
+
+    const results: Array<{ name: string; found: boolean }> = []
+    for (const check of checks) {
+      const found = await page.$(check.selector) !== null
+      results.push({ name: check.name, found })
+      console.log(`  ${found ? '‚úÖ' : '‚ùå'} ${check.name}`)
+    }
+
+    const allFound = results.every(r => r.found)
+    if (!allFound) {
+      throw new Error('Some required elements are missing')
+    }
+
+    // Court-ready assertion 1: Integrity page exists + has Hash Algorithm + SHA-256 block
+    console.log('üîç Court-ready check 1: Integrity & Verification page...')
+    try {
+      const integrityPage = await page.$('.page:has-text("Integrity & Verification"), .page:has-text("Integrity")')
+      if (!integrityPage) {
+        // Try finding by section header text
+        const integrityHeader = await page.$$eval('.section-header, .section-title', (elements) => {
+          return elements.some(el => el.textContent?.includes('Integrity') || el.textContent?.includes('Verification'))
+        })
+        if (!integrityHeader) {
+          throw new Error('Integrity & Verification page not found')
+        }
+      }
+
+      // Check for Hash Algorithm text
+      const pageText = await page.textContent('body') || ''
+      const hasHashAlgorithm = pageText.includes('Hash Algorithm') || pageText.includes('SHA-256')
+      if (!hasHashAlgorithm) {
+        throw new Error('Hash Algorithm/SHA-256 not found in Integrity page')
+      }
+
+      // Check for SHA-256 block (monospace or hash-like content)
+      const hashBlock = await page.$$eval('*', (elements) => {
+        return elements.some(el => {
+          const text = el.textContent || ''
+          const style = window.getComputedStyle(el)
+          return (text.length >= 32 && /[0-9a-f]{32,}/i.test(text)) || 
+                 style.fontFamily.includes('monospace')
+        })
+      })
+      console.log(`  ‚úÖ Integrity page found`)
+      console.log(`  ‚úÖ Hash Algorithm/SHA-256 content present`)
+      console.log(`  ${hashBlock ? '‚úÖ' : '‚ö†Ô∏è '} Hash block detected`)
+    } catch (error: any) {
+      throw new Error(`Integrity page check failed: ${error.message}`)
+    }
+
+    // Court-ready assertion 2: At least 1 .section-empty renders when there's no data
+    console.log('üîç Court-ready check 2: Empty state sections...')
+    try {
+      const emptySections = await page.$$('.section-empty')
+      const emptySectionCount = emptySections.length
+      console.log(`  Found ${emptySectionCount} empty section(s)`)
+      
+      if (emptySectionCount > 0) {
+        // Verify empty sections have the expected structure
+        const firstEmpty = emptySections[0]
+        const hasTitle = await firstEmpty.$('.section-title, h2') !== null
+        const hasMessage = await firstEmpty.$('.section-empty-message, .section-empty-content') !== null
+        
+        console.log(`  ‚úÖ Empty section structure verified`)
+        if (!hasTitle || !hasMessage) {
+          console.warn('  ‚ö†Ô∏è  Empty section may be missing expected structure')
+        }
+      } else {
+        console.log('  ‚ÑπÔ∏è  No empty sections found (all sections have data)')
+      }
+    } catch (error: any) {
+      console.warn(`  ‚ö†Ô∏è  Empty section check warning: ${error.message}`)
+      // Don't fail on this - it's informational
+    }
+
+    // Court-ready assertion 3: TOC titles match rendered section titles (basic count match)
+    console.log('üîç Court-ready check 3: TOC alignment...')
+    try {
+      // Count TOC items
+      const tocItems = await page.$$('.toc-item, .toc-list li, [class*="toc"] li')
+      const tocCount = tocItems.length
+
+      // Count section headers/titles (excluding TOC and Integrity which are always present)
+      const sectionHeaders = await page.$$eval('.section-header, .section-title', (elements) => {
+        return elements.filter(el => {
+          const text = el.textContent || ''
+          return !text.includes('Table of Contents') && !text.includes('Integrity')
+        }).length
+      })
+
+      console.log(`  TOC items: ${tocCount}, Section headers: ${sectionHeaders}`)
+      
+      // TOC should have approximately the same number of items as sections
+      // Allow some flexibility (TOC might exclude itself, Integrity is always last)
+      if (tocCount > 0 && sectionHeaders > 0) {
+        const ratio = tocCount / sectionHeaders
+        if (ratio < 0.5 || ratio > 1.5) {
+          console.warn(`  ‚ö†Ô∏è  TOC count (${tocCount}) doesn't align with sections (${sectionHeaders})`)
+          console.warn(`  ‚ö†Ô∏è  Ratio: ${ratio.toFixed(2)} (expected ~0.8-1.2)`)
+        } else {
+          console.log(`  ‚úÖ TOC alignment verified (ratio: ${ratio.toFixed(2)})`)
+        }
+      } else if (tocCount === 0) {
+        console.log('  ‚ÑπÔ∏è  No TOC found (may not be required for all packet types)')
+      }
+    } catch (error: any) {
+      console.warn(`  ‚ö†Ô∏è  TOC alignment check warning: ${error.message}`)
+      // Don't fail on this - it's informational
+    }
+
+    // Take screenshot of first page (cover)
+    console.log('üì∏ Taking screenshot...')
+    const coverPath = path.join(OUT_DIR, `${label}__cover.png`)
+    await page.screenshot({
+      path: coverPath,
+      fullPage: false,
+      clip: { x: 0, y: 0, width: 1200, height: 1600 },
+    })
+    console.log(`‚úÖ Saved: ${coverPath}`)
 
-    const response = await page.goto(PRINT_URL, {
-      waitUntil: 'networkidle',
-      timeout: 30000,
-    })
-
-    if (!response || response.status() !== 200) {
-      throw new Error(`Failed to load page: HTTP ${response?.status()}`)
-    }
-
-    console.log('‚úÖ Page loaded successfully')
-
-    // Wait for PDF ready marker (critical - PDF service waits for this)
-    console.log('‚è≥ Waiting for PDF ready marker (#pdf-ready[data-ready="1"])...')
-    try {
-      await page.waitForSelector('#pdf-ready[data-ready="1"]', {
-        timeout: 15000,
-      })
-      console.log('‚úÖ PDF ready marker found')
-    } catch (error) {
-      // Retry once for flaky headless
-      console.log('‚ö†Ô∏è  Marker not found immediately, retrying...')
-      try {
-        await page.waitForSelector('#pdf-ready[data-ready="1"]', {
-          timeout: 10000,
-        })
-        console.log('‚úÖ PDF ready marker found on retry')
-      } catch (retryError) {
-        throw new Error('PDF ready marker not found - PDF service will hang!')
-      }
-    }
-
-    // Verify key selectors exist
-    console.log('üîç Verifying page structure...')
-    const checks = [
-      { selector: '.cover-page', name: 'Cover page' },
-      { selector: '.section-header, .section-title', name: 'Section headers' },
-      { selector: 'body[data-organization-name]', name: 'Organization metadata' },
-      { selector: 'body[data-job-id]', name: 'Job ID metadata' },
-      { selector: 'body[data-run-id]', name: 'Run ID metadata' },
-    ]
-
-    const results: Array<{ name: string; found: boolean }> = []
-    for (const check of checks) {
-      const found = await page.$(check.selector) !== null
-      results.push({ name: check.name, found })
-      console.log(`  ${found ? '‚úÖ' : '‚ùå'} ${check.name}`)
-    }
-
-    const allFound = results.every(r => r.found)
-    if (!allFound) {
-      throw new Error('Some required elements are missing')
-    }
-
-    // Court-ready assertion 1: Integrity page exists + has Hash Algorithm + SHA-256 block
-    console.log('üîç Court-ready check 1: Integrity & Verification page...')
-    try {
-      const integrityPage = await page.$('.page:has-text("Integrity & Verification"), .page:has-text("Integrity")')
-      if (!integrityPage) {
-        // Try finding by section header text
-        const integrityHeader = await page.$$eval('.section-header, .section-title', (elements) => {
-          return elements.some(el => el.textContent?.includes('Integrity') || el.textContent?.includes('Verification'))
-        })
-        if (!integrityHeader) {
-          throw new Error('Integrity & Verification page not found')
-        }
-      }
-
-      // Check for Hash Algorithm text
-      const pageText = await page.textContent('body') || ''
-      const hasHashAlgorithm = pageText.includes('Hash Algorithm') || pageText.includes('SHA-256')
-      if (!hasHashAlgorithm) {
-        throw new Error('Hash Algorithm/SHA-256 not found in Integrity page')
-      }
-
-      // Check for SHA-256 block (monospace or hash-like content)
-      const hashBlock = await page.$$eval('*', (elements) => {
-        return elements.some(el => {
-          const text = el.textContent || ''
-          const style = window.getComputedStyle(el)
-          return (text.length >= 32 && /[0-9a-f]{32,}/i.test(text)) || 
-                 style.fontFamily.includes('monospace')
-        })
-      })
-      console.log(`  ‚úÖ Integrity page found`)
-      console.log(`  ‚úÖ Hash Algorithm/SHA-256 content present`)
-      console.log(`  ${hashBlock ? '‚úÖ' : '‚ö†Ô∏è '} Hash block detected`)
-    } catch (error: any) {
-      throw new Error(`Integrity page check failed: ${error.message}`)
-    }
-
-    // Court-ready assertion 2: At least 1 .section-empty renders when there's no data
-    console.log('üîç Court-ready check 2: Empty state sections...')
-    try {
-      const emptySections = await page.$$('.section-empty')
-      const emptySectionCount = emptySections.length
-      console.log(`  Found ${emptySectionCount} empty section(s)`)
-      
-      if (emptySectionCount > 0) {
-        // Verify empty sections have the expected structure
-        const firstEmpty = emptySections[0]
-        const hasTitle = await firstEmpty.$('.section-title, h2') !== null
-        const hasMessage = await firstEmpty.$('.section-empty-message, .section-empty-content') !== null
-        
-        console.log(`  ‚úÖ Empty section structure verified`)
-        if (!hasTitle || !hasMessage) {
-          console.warn('  ‚ö†Ô∏è  Empty section may be missing expected structure')
-        }
+    if (page) {
+      try {
+        // Take screenshot of error state
+        const urlObj = new URL(PRINT_URL)
+        const runId = urlObj.pathname.split('/').pop() || 'unknown_run'
+        const errLabel = safeName(process.env.PACKET_LABEL || runId)
+        const errPath = path.join(OUT_DIR, `${errLabel}__error.png`)
+        await page.screenshot({ path: errPath, fullPage: true })
+        console.error(`   Saved error screenshot: ${errPath}`)
+      } catch (screenshotError) {
+        console.error('   Could not capture error screenshot:', screenshotError)
       } else {
-        console.log('  ‚ÑπÔ∏è  No empty sections found (all sections have data)')
+        console.error('   Could not capture error screenshot - page is null')
       }
-    } catch (error: any) {
-      console.warn(`  ‚ö†Ô∏è  Empty section check warning: ${error.message}`)
-      // Don't fail on this - it's informational
-    }
-
-    // Court-ready assertion 3: TOC titles match rendered section titles (basic count match)
-    console.log('üîç Court-ready check 3: TOC alignment...')
-    try {
-      // Count TOC items
-      const tocItems = await page.$$('.toc-item, .toc-list li, [class*="toc"] li')
-      const tocCount = tocItems.length
-
-      // Count section headers/titles (excluding TOC and Integrity which are always present)
-      const sectionHeaders = await page.$$eval('.section-header, .section-title', (elements) => {
-        return elements.filter(el => {
-          const text = el.textContent || ''
-          return !text.includes('Table of Contents') && !text.includes('Integrity')
-        }).length
-      })
-
-      console.log(`  TOC items: ${tocCount}, Section headers: ${sectionHeaders}`)
-      
-      // TOC should have approximately the same number of items as sections
-      // Allow some flexibility (TOC might exclude itself, Integrity is always last)
-      if (tocCount > 0 && sectionHeaders > 0) {
-        const ratio = tocCount / sectionHeaders
-        if (ratio < 0.5 || ratio > 1.5) {
-          console.warn(`  ‚ö†Ô∏è  TOC count (${tocCount}) doesn't align with sections (${sectionHeaders})`)
-          console.warn(`  ‚ö†Ô∏è  Ratio: ${ratio.toFixed(2)} (expected ~0.8-1.2)`)
-        } else {
-          console.log(`  ‚úÖ TOC alignment verified (ratio: ${ratio.toFixed(2)})`)
-        }
-      } else if (tocCount === 0) {
-        console.log('  ‚ÑπÔ∏è  No TOC found (may not be required for all packet types)')
-      }
-    } catch (error: any) {
-      console.warn(`  ‚ö†Ô∏è  TOC alignment check warning: ${error.message}`)
-      // Don't fail on this - it's informational
-    }
-
-    // Take screenshot of first page (cover)
-    console.log('üì∏ Taking screenshot...')
-    const screenshotBuffer = await page.screenshot({
-      fullPage: false,
-      clip: { x:  my changes didn't apply correctly. Let me read the file and make a more targeted fix:
+        const coverPath = path.join(OUT_DIR, `${label}__cover.png`)
+        await page.screenshot({
+          path: coverPath,
+          fullPage: false,
+          clip: { x: 0, y: 0, width: 1200, height: 1600 },
+        })
+        console.log(`‚úÖ Saved: ${coverPath}`)

