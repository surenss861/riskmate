"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.drawHeader = drawHeader;
exports.drawFooter = drawFooter;
exports.drawSectionTitle = drawSectionTitle;
exports.drawKpiRow = drawKpiRow;
exports.drawTable = drawTable;
exports.drawEmptyState = drawEmptyState;
exports.formatHashShort = formatHashShort;
exports.initPage = initPage;
exports.finalizePdf = finalizePdf;
const styles_1 = require("./styles");
const helpers_1 = require("./helpers");
const normalize_1 = require("./normalize");
/**
 * Shared PDF theme for all proof pack PDFs
 */
// Draw consistent header with RiskMate branding
function drawHeader(doc, options) {
    const margin = styles_1.STYLES.spacing.pageMargin;
    doc.y = margin;
    // Title with orange accent underline (sanitize to prevent control characters)
    doc
        .fillColor(styles_1.STYLES.colors.primaryText)
        .fontSize(styles_1.STYLES.sizes.h1)
        .font(styles_1.STYLES.fonts.header)
        .text((0, normalize_1.safeTextForPdf)(options.title, 'Header title'), margin, margin, { align: 'left' });
    const underlineY = doc.y - 4;
    doc
        .strokeColor(styles_1.STYLES.colors.accent)
        .lineWidth(2)
        .moveTo(margin, underlineY)
        .lineTo(margin + 200, underlineY)
        .stroke();
    doc.moveDown(0.5);
    // Metadata block (compact, organized)
    doc
        .fillColor(styles_1.STYLES.colors.secondaryText)
        .fontSize(styles_1.STYLES.sizes.caption)
        .font(styles_1.STYLES.fonts.body);
    if (options.packId) {
        doc.text((0, normalize_1.safeTextForPdf)(`Pack ID: ${options.packId}`, 'Header packId'), { align: 'left' });
    }
    if (options.organizationName) {
        doc.text((0, normalize_1.safeTextForPdf)(`Organization: ${options.organizationName}`, 'Header organizationName'), { align: 'left' });
    }
    if (options.generatedBy && options.generatedByRole) {
        doc.text((0, normalize_1.safeTextForPdf)(`Generated By: ${options.generatedBy} (${options.generatedByRole})`, 'Header generatedBy'), { align: 'left' });
    }
    if (options.generatedAt) {
        doc.text((0, normalize_1.safeTextForPdf)(`Generated: ${new Date(options.generatedAt).toLocaleString()}`, 'Header generatedAt'), { align: 'left' });
    }
    if (options.timeRange) {
        doc.text((0, normalize_1.safeTextForPdf)(`Time Range: ${options.timeRange}`, 'Header timeRange'), { align: 'left' });
    }
    doc.moveDown(1);
}
// Draw footer with page numbers
function drawFooter(doc, options) {
    const pageHeight = doc.page.height;
    const margin = styles_1.STYLES.spacing.pageMargin;
    doc
        .fillColor(styles_1.STYLES.colors.secondaryText)
        .fontSize(styles_1.STYLES.sizes.caption)
        .font(styles_1.STYLES.fonts.body)
        .text((0, normalize_1.safeTextForPdf)(options.totalPages
        ? `Page ${options.pageNumber} of ${options.totalPages}`
        : `Page ${options.pageNumber}`, 'Footer page number'), margin, pageHeight - 40, { align: 'left' });
    if (options.packId) {
        doc.text((0, normalize_1.safeTextForPdf)(`Pack ID: ${options.packId}`, 'Footer packId'), doc.page.width - margin, pageHeight - 40, { align: 'right' });
    }
}
// Draw section title with consistent styling
function drawSectionTitle(doc, text) {
    doc.moveDown(0.8);
    doc
        .fillColor(styles_1.STYLES.colors.primaryText)
        .fontSize(styles_1.STYLES.sizes.h3)
        .font(styles_1.STYLES.fonts.header)
        .text((0, normalize_1.safeTextForPdf)(text, 'Section title'), { align: 'left' });
    // Subtle divider line
    const dividerY = doc.y - 4;
    doc
        .strokeColor(styles_1.STYLES.colors.divider)
        .lineWidth(0.5)
        .moveTo(styles_1.STYLES.spacing.pageMargin, dividerY)
        .lineTo(doc.page.width - styles_1.STYLES.spacing.pageMargin, dividerY)
        .stroke();
    doc.moveDown(0.5);
}
// Draw KPI row (summary stats as tiles)
function drawKpiRow(doc, stats) {
    const margin = styles_1.STYLES.spacing.pageMargin;
    const pageWidth = doc.page.width;
    const availableWidth = pageWidth - (margin * 2);
    const tileWidth = availableWidth / stats.length;
    const tileHeight = 40;
    const startY = doc.y;
    stats.forEach((stat, index) => {
        const x = margin + (tileWidth * index);
        // Tile background
        doc
            .rect(x, startY, tileWidth - 8, tileHeight)
            .fillColor(stat.highlight ? styles_1.STYLES.colors.accentLight : styles_1.STYLES.colors.lightGrayBg)
            .fill()
            .strokeColor(styles_1.STYLES.colors.borderGray)
            .lineWidth(0.5)
            .stroke();
        // Label (sanitize to prevent control characters)
        doc
            .fillColor(styles_1.STYLES.colors.secondaryText)
            .fontSize(styles_1.STYLES.sizes.caption)
            .font(styles_1.STYLES.fonts.body)
            .text((0, normalize_1.safeTextForPdf)(stat.label, `KPI label: ${stat.label}`), x + 8, startY + 6, { width: tileWidth - 16, align: 'left' });
        // Value (sanitize to prevent control characters - especially important for string values)
        const valueText = typeof stat.value === 'string' ? (0, normalize_1.safeTextForPdf)(stat.value, `KPI value: ${stat.label}`) : String(stat.value);
        doc
            .fillColor(stat.highlight ? styles_1.STYLES.colors.accent : styles_1.STYLES.colors.primaryText)
            .fontSize(styles_1.STYLES.sizes.body)
            .font(styles_1.STYLES.fonts.header)
            .text(valueText, x + 8, startY + 20, { width: tileWidth - 16, align: 'left' });
    });
    doc.y = startY + tileHeight + 12;
}
// Draw table with proper pagination, wrapping, and styling
/**
 * Truncate text to fit within a given width, adding ellipsis if needed
 * Uses binary search to find the maximum text length that fits
 */
function truncateToWidth(doc, text, width, opts) {
    const clean = (0, normalize_1.safeTextForPdf)(String(text ?? ''), 'truncateToWidth');
    doc.font(opts.font).fontSize(opts.fontSize);
    if (doc.widthOfString(clean) <= width)
        return clean;
    const ell = 'â€¦';
    if (doc.widthOfString(ell) > width)
        return ''; // width too tiny
    // Binary search best fit
    let lo = 0;
    let hi = clean.length;
    while (lo < hi) {
        const mid = Math.ceil((lo + hi) / 2);
        const candidate = clean.slice(0, mid) + ell;
        if (doc.widthOfString(candidate) <= width)
            lo = mid;
        else
            hi = mid - 1;
    }
    return clean.slice(0, lo) + ell;
}
function drawTable(doc, options) {
    const margin = styles_1.STYLES.spacing.pageMargin;
    const pageWidth = doc.page.width;
    const pageHeight = doc.page.height;
    const rowHeight = options.rowHeight || 20;
    const fontSize = options.fontSize || 8;
    const zebraStriping = options.zebraStriping !== false;
    // CRITICAL FIX: Account for column gaps in width normalization
    const columnGap = 4;
    const colCount = options.columns.length;
    const availableWidth = pageWidth - (margin * 2);
    const availableForColumns = availableWidth - columnGap * Math.max(0, colCount - 1);
    let currentY = doc.y;
    let isFirstPage = true;
    let rowIndex = 0;
    // Calculate column widths (normalize to available width *minus gaps*)
    const totalColumnWidth = options.columns.reduce((sum, col) => sum + col.width, 0);
    const scaleFactor = availableForColumns / totalColumnWidth;
    const normalizedColumns = options.columns.map(col => ({
        ...col,
        width: col.width * scaleFactor,
    }));
    const drawTableHeader = (y) => {
        doc
            .fontSize(fontSize)
            .font(styles_1.STYLES.fonts.header)
            .fillColor(styles_1.STYLES.colors.primaryText);
        let x = margin;
        normalizedColumns.forEach((col) => {
            // Truncate header text to fit width, prevent wrapping
            const headerText = truncateToWidth(doc, col.header, col.width, {
                font: styles_1.STYLES.fonts.header,
                fontSize,
            });
            doc.text(headerText, x, y, {
                width: col.width,
                align: col.align || 'left',
                lineBreak: false, // Prevent line breaks inside cells
            });
            x += col.width + columnGap;
        });
        // Header underline
        doc
            .strokeColor(styles_1.STYLES.colors.borderGray)
            .lineWidth(1)
            .moveTo(margin, y + 15)
            .lineTo(pageWidth - margin, y + 15)
            .stroke();
    };
    const drawTableRow = (row, y, isEven) => {
        // Zebra striping background
        if (zebraStriping && isEven) {
            doc
                .rect(margin, y - 2, availableWidth, rowHeight)
                .fillColor(styles_1.STYLES.colors.lightGrayBg)
                .fill();
        }
        doc
            .fontSize(fontSize)
            .font(styles_1.STYLES.fonts.body)
            .fillColor(styles_1.STYLES.colors.primaryText);
        let x = margin;
        normalizedColumns.forEach((col, colIndex) => {
            const cellValue = row[colIndex] ?? '';
            // CRITICAL: Truncate to width to prevent wrapping, use lineBreak: false
            const cellText = truncateToWidth(doc, cellValue, col.width, {
                font: styles_1.STYLES.fonts.body,
                fontSize,
            });
            doc.text(cellText, x, y, {
                width: col.width,
                align: col.align || 'left',
                lineBreak: false, // Prevent line breaks inside cells
            });
            x += col.width + columnGap;
        });
    };
    // Draw header on first page
    if (options.rows.length > 0) {
        drawTableHeader(currentY);
        currentY += rowHeight + 8;
    }
    // Draw rows with pagination
    options.rows.forEach((row, index) => {
        // Check if we need a new page
        if (currentY + rowHeight > pageHeight - 60) {
            // New page (don't add footer here - finalizePdf handles all footers)
            doc.addPage();
            (0, helpers_1.addWatermark)(doc);
            currentY = margin + 40;
            // Redraw header on new page
            drawTableHeader(currentY);
            currentY += rowHeight + 8;
            isFirstPage = false;
        }
        const isEven = rowIndex % 2 === 0;
        drawTableRow(row, currentY, isEven);
        currentY += rowHeight;
        rowIndex++;
    });
    doc.y = currentY + 12;
}
// Draw empty state card
function drawEmptyState(doc, options) {
    const margin = styles_1.STYLES.spacing.pageMargin;
    const pageWidth = doc.page.width;
    const cardWidth = pageWidth - (margin * 2);
    const cardHeight = 120;
    const cardY = doc.y;
    // Card background
    doc
        .rect(margin, cardY, cardWidth, cardHeight)
        .fillColor(styles_1.STYLES.colors.cardBg)
        .fill()
        .strokeColor(styles_1.STYLES.colors.borderGray)
        .lineWidth(1)
        .stroke();
    // Title (sanitize to prevent control characters)
    doc
        .fillColor(styles_1.STYLES.colors.primaryText)
        .fontSize(styles_1.STYLES.sizes.h3)
        .font(styles_1.STYLES.fonts.header)
        .text((0, normalize_1.safeTextForPdf)(options.title, 'Empty state title'), margin + 16, cardY + 16, { align: 'left' });
    // Message (sanitize to prevent control characters)
    doc
        .fillColor(styles_1.STYLES.colors.secondaryText)
        .fontSize(styles_1.STYLES.sizes.body)
        .font(styles_1.STYLES.fonts.body)
        .text((0, normalize_1.safeTextForPdf)(options.message, 'Empty state message'), margin + 16, cardY + 40, {
        width: cardWidth - 32,
        align: 'left',
    });
    // Filters (if provided)
    if (options.filters && Object.keys(options.filters).length > 0) {
        const filterText = Object.entries(options.filters)
            .filter(([_, v]) => v !== null && v !== undefined && v !== '')
            .map(([k, v]) => `${k}: ${v}`)
            .join(', ');
        if (filterText) {
            doc
                .fontSize(styles_1.STYLES.sizes.caption)
                .text((0, normalize_1.safeTextForPdf)(`Applied filters: ${filterText}`, 'Empty state filters'), margin + 16, cardY + 70, {
                width: cardWidth - 32,
                align: 'left',
            });
        }
    }
    // Action hint
    if (options.actionHint) {
        doc
            .fillColor(styles_1.STYLES.colors.accent)
            .fontSize(styles_1.STYLES.sizes.caption)
            .font(styles_1.STYLES.fonts.body)
            .text((0, normalize_1.safeTextForPdf)(options.actionHint, 'Empty state actionHint'), margin + 16, cardY + 90, {
            width: cardWidth - 32,
            align: 'left',
        });
    }
    doc.y = cardY + cardHeight + 20;
}
// Format hash for display (short version)
function formatHashShort(hash, length = 16) {
    if (!hash || hash.length < length)
        return hash;
    return `${hash.substring(0, length)}...${hash.substring(hash.length - 8)}`;
}
// Initialize page with watermark and header space
function initPage(doc) {
    (0, helpers_1.addWatermark)(doc);
    doc.y = styles_1.STYLES.spacing.sectionTop;
}
/**
 * Finalize PDF with proper page buffering and footers
 * PDFDocument must be created with bufferPages: true option
 */
function finalizePdf(doc, meta) {
    // Get the buffered page range (may not start at 0)
    const range = doc.bufferedPageRange();
    if (!range || range.count === 0) {
        // No pages buffered, nothing to finalize
        return;
    }
    // Draw footer on each page using correct page indices
    // Never assume page 0 exists - always use range.start
    for (let i = range.start; i < range.start + range.count; i++) {
        doc.switchToPage(i);
        drawFooter(doc, {
            pageNumber: i - range.start + 1, // Page number (1-based, relative to range)
            totalPages: range.count,
            packId: meta.packId,
        });
    }
    // Flush buffered pages
    ;
    doc.flushPages();
}
//# sourceMappingURL=proofPackTheme.js.map