import PDFDocument from 'pdfkit'
import crypto from 'crypto'

interface ExecutiveBriefData {
  generated_at: string
  time_range: string
  summary: {
    exposure_level: 'low' | 'moderate' | 'high'
    confidence_statement: string
    counts: {
      high_risk_jobs: number
      open_incidents: number
      violations: number
      flagged: number
      pending_attestations: number
      signed_attestations: number
      proof_packs: number
    }
    deltas?: {
      high_risk_jobs: number
      open_incidents: number
      violations: number
      flagged_jobs: number
      pending_signoffs: number
      signed_signoffs: number
      proof_packs: number
    }
    top_drivers?: {
      highRiskJobs?: Array<{ label: string; count: number }>
      openIncidents?: Array<{ label: string; count: number }>
      violations?: Array<{ label: string; count: number }>
      flagged?: Array<{ label: string; count: number }>
      pending?: Array<{ label: string; count: number }>
    }
    integrity?: {
      status: 'verified' | 'error' | 'not_verified'
      last_verified_at?: string | null
    }
    recommended_actions?: Array<{
      priority: number
      action: string
      reason: string
    }>
  }
}

export async function generateExecutiveBriefPDF(
  brief: ExecutiveBriefData,
  organizationName: string,
  generatedBy: string
): Promise<{ buffer: Buffer; hash: string }> {
  return new Promise((resolve, reject) => {
    const doc = new PDFDocument({
      size: 'LETTER',
      margins: {
        top: 50,
        bottom: 50,
        left: 50,
        right: 50,
      },
    })

    const chunks: Buffer[] = []
    doc.on('data', (chunk) => chunks.push(chunk))
    doc.on('end', () => {
      const buffer = Buffer.concat(chunks)
      const hash = crypto.createHash('sha256').update(buffer).digest('hex')
      resolve({ buffer, hash })
    })
    doc.on('error', reject)

    const { summary } = brief

    // Header
    doc.fontSize(24).font('Helvetica-Bold').text('Executive Risk Posture Brief', { align: 'center' })
    doc.moveDown(0.3)
    doc.fontSize(10).font('Helvetica')
    doc.text(`Generated: ${new Date(brief.generated_at).toLocaleDateString()} ${new Date(brief.generated_at).toLocaleTimeString()}`, { align: 'center' })
    doc.text(`Time Range: ${brief.time_range}`, { align: 'center' })
    doc.text(`Organization: ${organizationName}`, { align: 'center' })
    doc.text(`Generated By: ${generatedBy}`, { align: 'center' })
    doc.moveDown(0.5)

    // Headline / Confidence Statement
    doc.fontSize(14).font('Helvetica-Bold').text('Summary', { underline: true })
    doc.moveDown(0.2)
    doc.fontSize(11).font('Helvetica')
    doc.text(summary.confidence_statement, { align: 'left' })
    doc.moveDown(0.3)
    
    // Exposure Level
    const exposureColor = summary.exposure_level === 'high' ? [255, 0, 0] : summary.exposure_level === 'moderate' ? [255, 165, 0] : [0, 128, 0]
    doc.fillColor(`rgb(${exposureColor.join(',')})`)
    doc.text(`Exposure Level: ${summary.exposure_level.toUpperCase()}`, { continued: false })
    doc.fillColor('black')
    doc.moveDown(0.5)

    // Key Metrics with Deltas
    doc.fontSize(12).font('Helvetica-Bold').text('Key Metrics', { underline: true })
    doc.moveDown(0.2)
    doc.fontSize(10).font('Helvetica')
    
    const formatDelta = (delta?: number) => {
      if (!delta || delta === 0) return ''
      const sign = delta > 0 ? '+' : ''
      return ` (${sign}${delta})`
    }

    const metrics = [
      ['High Risk Jobs', summary.counts.high_risk_jobs, summary.deltas?.high_risk_jobs],
      ['Open Incidents', summary.counts.open_incidents, summary.deltas?.open_incidents],
      ['Violations', summary.counts.violations, summary.deltas?.violations],
      ['Flagged for Review', summary.counts.flagged, summary.deltas?.flagged_jobs],
      ['Pending Attestations', summary.counts.pending_attestations, summary.deltas?.pending_signoffs],
      ['Signed Attestations', summary.counts.signed_attestations, summary.deltas?.signed_signoffs],
      ['Proof Packs', summary.counts.proof_packs, summary.deltas?.proof_packs],
    ]

    metrics.forEach(([label, count, delta]) => {
      const deltaText = formatDelta(delta)
      doc.text(`${label}: ${count}${deltaText}`, { indent: 20 })
    })
    doc.moveDown(0.5)

    // Top Drivers
    if (summary.top_drivers) {
      doc.fontSize(12).font('Helvetica-Bold').text('Top Drivers', { underline: true })
      doc.moveDown(0.2)
      doc.fontSize(10).font('Helvetica')

      const drivers = [
        ...(summary.top_drivers.highRiskJobs || []).map(d => `High Risk: ${d.label} (${d.count})`),
        ...(summary.top_drivers.openIncidents || []).map(d => `Incidents: ${d.label} (${d.count})`),
        ...(summary.top_drivers.violations || []).map(d => `Violations: ${d.label} (${d.count})`),
        ...(summary.top_drivers.flagged || []).map(d => `Flagged: ${d.label} (${d.count})`),
        ...(summary.top_drivers.pending || []).map(d => `Pending: ${d.label} (${d.count})`),
      ]

      drivers.slice(0, 5).forEach(driver => {
        doc.text(`• ${driver}`, { indent: 20 })
      })
      doc.moveDown(0.5)
    }

    // Integrity Status
    if (summary.integrity) {
      doc.fontSize(12).font('Helvetica-Bold').text('Ledger Integrity', { underline: true })
      doc.moveDown(0.2)
      doc.fontSize(10).font('Helvetica')
      
      const integrityStatus = summary.integrity.status === 'verified' ? '✅ Verified' 
        : summary.integrity.status === 'error' ? '❌ Integrity Error'
        : '⚠️ Not Yet Verified'
      
      doc.text(integrityStatus, { indent: 20 })
      if (summary.integrity.last_verified_at) {
        doc.text(`Last Verified: ${new Date(summary.integrity.last_verified_at).toLocaleDateString()}`, { indent: 20 })
      }
      doc.moveDown(0.5)
    }

    // Recommended Actions
    if (summary.recommended_actions && summary.recommended_actions.length > 0) {
      doc.fontSize(12).font('Helvetica-Bold').text('Recommended Actions', { underline: true })
      doc.moveDown(0.2)
      doc.fontSize(10).font('Helvetica')

      summary.recommended_actions.slice(0, 3).forEach((action, idx) => {
        doc.text(`#${action.priority}: ${action.action}`, { indent: 20, continued: false })
        doc.fontSize(9).font('Helvetica-Oblique')
        doc.text(`   ${action.reason}`, { indent: 20 })
        doc.fontSize(10).font('Helvetica')
        doc.moveDown(0.2)
      })
    }

    // Footer with hash
    const pageCount = doc.bufferedPageRange().count
    for (let i = 0; i < pageCount; i++) {
      doc.switchToPage(i)
      doc.fontSize(8).font('Helvetica-Oblique')
      doc.text(
        `RiskMate Executive Brief | Generated ${new Date(brief.generated_at).toLocaleDateString()} | Page ${i + 1} of ${pageCount}`,
        50,
        doc.page.height - 30,
        { align: 'center', width: doc.page.width - 100 }
      )
    }

    doc.end()
  })
}

