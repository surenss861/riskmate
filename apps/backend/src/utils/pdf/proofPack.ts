import PDFDocument from 'pdfkit'
import { STYLES } from './styles'
import { addSectionHeader, addWatermark } from './helpers'

// Control row can be any object with these fields (from CSV parsing)
interface ControlRow {
  control_id?: string
  ledger_entry_id?: string
  ledger_event_type?: string
  work_record_id?: string
  site_id?: string
  org_id?: string
  status_at_export?: string
  severity?: string
  title?: string
  owner_user_id?: string
  owner_email?: string
  due_date?: string
  verification_method?: string
  created_at?: string
  updated_at?: string
  [key: string]: any // Allow additional fields from CSV
}

// Attestation row can be any object with these fields (from CSV parsing)
interface AttestationRow {
  attestation_id?: string
  ledger_entry_id?: string
  ledger_event_type?: string
  work_record_id?: string
  site_id?: string
  org_id?: string
  status_at_export?: string
  title?: string
  description?: string
  attested_by_user_id?: string
  attested_by_email?: string
  attested_at?: string
  created_at?: string
  [key: string]: any // Allow additional fields from CSV
}

interface ProofPackMeta {
  packId: string
  organizationName: string
  generatedBy: string
  generatedByRole: string
  generatedAt: string
  timeRange: string
}

/**
 * Generate Controls PDF from controls data
 */
export async function generateControlsPDF(
  controls: ControlRow[],
  meta: ProofPackMeta
): Promise<Buffer> {
  return new Promise((resolve, reject) => {
    const doc = new PDFDocument({
      size: 'LETTER',
      margins: {
        top: STYLES.spacing.pageMargin,
        bottom: 60,
        left: STYLES.spacing.pageMargin,
        right: STYLES.spacing.pageMargin,
      },
    })

    const chunks: Buffer[] = []
    doc.on('data', (chunk) => chunks.push(chunk))
    doc.on('end', () => resolve(Buffer.concat(chunks)))
    doc.on('error', reject)

    // Add watermark
    addWatermark(doc)

    // Header
    doc.y = STYLES.spacing.sectionTop
    doc
      .fillColor(STYLES.colors.primaryText)
      .fontSize(STYLES.sizes.h1)
      .font(STYLES.fonts.header)
      .text('Controls Report', { align: 'left' })

    // Orange underline
    const underlineY = doc.y - 4
    doc
      .strokeColor(STYLES.colors.accent)
      .lineWidth(2)
      .moveTo(STYLES.spacing.pageMargin, underlineY)
      .lineTo(STYLES.spacing.pageMargin + 150, underlineY)
      .stroke()

    doc.moveDown(0.5)

    // Metadata
    doc
      .fillColor(STYLES.colors.secondaryText)
      .fontSize(STYLES.sizes.body)
      .font(STYLES.fonts.body)
      .text(`Pack ID: ${meta.packId}`, { align: 'left' })
      .text(`Organization: ${meta.organizationName}`, { align: 'left' })
      .text(`Generated: ${meta.generatedAt}`, { align: 'left' })
      .text(`Generated By: ${meta.generatedBy} (${meta.generatedByRole})`, { align: 'left' })
      .text(`Time Range: ${meta.timeRange}`, { align: 'left' })
      .text(`Total Controls: ${controls.length}`, { align: 'left' })
      .text(`Completed: ${controls.filter(c => c.status_at_export === 'completed').length}`, { align: 'left' })
      .text(`Pending: ${controls.filter(c => c.status_at_export === 'pending').length}`, { align: 'left' })

    doc.moveDown(1)

    // Table headers
    const tableTop = doc.y
    const colWidths = [60, 100, 80, 60, 80, 100]
    const headers = ['Control ID', 'Title', 'Status', 'Severity', 'Owner', 'Due Date']
    
    doc.fontSize(9).font(STYLES.fonts.header).fillColor(STYLES.colors.primaryText)
    let x = STYLES.spacing.pageMargin
    headers.forEach((header, i) => {
      doc.text(header, x, tableTop, { width: colWidths[i], align: 'left' })
      x += colWidths[i] + 10
    })

    // Table rows
    doc.fontSize(8).font(STYLES.fonts.body)
    let y = tableTop + 20
    
    controls.forEach((control) => {
      if (y > doc.page.height - 100) {
        doc.addPage()
        addWatermark(doc)
        y = STYLES.spacing.sectionTop
      }
      
      x = STYLES.spacing.pageMargin
      const row = [
        (control.control_id || '').substring(0, 12) + ((control.control_id || '').length > 12 ? '...' : ''),
        control.title || 'Untitled',
        control.status_at_export || 'unknown',
        control.severity || 'info',
        control.owner_email || 'Unassigned',
        control.due_date ? new Date(control.due_date).toLocaleDateString() : 'N/A',
      ]
      
      // Color code status
      if ((control.status_at_export || '') === 'completed') {
        doc.fillColor(STYLES.colors.riskLow)
      } else {
        doc.fillColor(STYLES.colors.primaryText)
      }
      
      row.forEach((cell, i) => {
        doc.text(String(cell).substring(0, 40), x, y, { width: colWidths[i], align: 'left' })
        x += colWidths[i] + 10
      })
      
      doc.fillColor(STYLES.colors.primaryText) // Reset color
      y += 15
    })

    doc.end()
  })
}

/**
 * Generate Attestations PDF from attestations data
 */
export async function generateAttestationsPDF(
  attestations: AttestationRow[],
  meta: ProofPackMeta
): Promise<Buffer> {
  return new Promise((resolve, reject) => {
    const doc = new PDFDocument({
      size: 'LETTER',
      margins: {
        top: STYLES.spacing.pageMargin,
        bottom: 60,
        left: STYLES.spacing.pageMargin,
        right: STYLES.spacing.pageMargin,
      },
    })

    const chunks: Buffer[] = []
    doc.on('data', (chunk) => chunks.push(chunk))
    doc.on('end', () => resolve(Buffer.concat(chunks)))
    doc.on('error', reject)

    addWatermark(doc)

    // Header
    doc.y = STYLES.spacing.sectionTop
    doc
      .fillColor(STYLES.colors.primaryText)
      .fontSize(STYLES.sizes.h1)
      .font(STYLES.fonts.header)
      .text('Attestations Report', { align: 'left' })

    // Orange underline
    const underlineY = doc.y - 4
    doc
      .strokeColor(STYLES.colors.accent)
      .lineWidth(2)
      .moveTo(STYLES.spacing.pageMargin, underlineY)
      .lineTo(STYLES.spacing.pageMargin + 180, underlineY)
      .stroke()

    doc.moveDown(0.5)

    // Metadata
    doc
      .fillColor(STYLES.colors.secondaryText)
      .fontSize(STYLES.sizes.body)
      .font(STYLES.fonts.body)
      .text(`Pack ID: ${meta.packId}`, { align: 'left' })
      .text(`Organization: ${meta.organizationName}`, { align: 'left' })
      .text(`Generated: ${meta.generatedAt}`, { align: 'left' })
      .text(`Generated By: ${meta.generatedBy} (${meta.generatedByRole})`, { align: 'left' })
      .text(`Time Range: ${meta.timeRange}`, { align: 'left' })
      .text(`Total Attestations: ${attestations.length}`, { align: 'left' })

    doc.moveDown(1)

    // Table headers
    const tableTop = doc.y
    const colWidths = [60, 120, 80, 100, 100]
    const headers = ['Attestation ID', 'Title', 'Status', 'Attested By', 'Attested At']
    
    doc.fontSize(9).font(STYLES.fonts.header).fillColor(STYLES.colors.primaryText)
    let x = STYLES.spacing.pageMargin
    headers.forEach((header, i) => {
      doc.text(header, x, tableTop, { width: colWidths[i], align: 'left' })
      x += colWidths[i] + 10
    })

    // Table rows
    doc.fontSize(8).font(STYLES.fonts.body)
    let y = tableTop + 20
    
    attestations.forEach((attestation) => {
      if (y > doc.page.height - 100) {
        doc.addPage()
        addWatermark(doc)
        y = STYLES.spacing.sectionTop
      }
      
      x = STYLES.spacing.pageMargin
      const row = [
        (attestation.attestation_id || '').substring(0, 12) + ((attestation.attestation_id || '').length > 12 ? '...' : ''),
        attestation.title || 'Untitled',
        attestation.status_at_export || 'unknown',
        attestation.attested_by_email || 'Unknown',
        attestation.attested_at ? new Date(attestation.attested_at).toLocaleString() : 'N/A',
      ]
      
      row.forEach((cell, i) => {
        doc.text(String(cell).substring(0, 50), x, y, { width: colWidths[i], align: 'left' })
        x += colWidths[i] + 10
      })
      
      y += 15
    })

    doc.end()
  })
}

/**
 * Generate Evidence Index PDF from manifest data
 */
export async function generateEvidenceIndexPDF(
  manifest: any,
  meta: ProofPackMeta
): Promise<Buffer> {
  return new Promise((resolve, reject) => {
    const doc = new PDFDocument({
      size: 'LETTER',
      margins: {
        top: STYLES.spacing.pageMargin,
        bottom: 60,
        left: STYLES.spacing.pageMargin,
        right: STYLES.spacing.pageMargin,
      },
    })

    const chunks: Buffer[] = []
    doc.on('data', (chunk) => chunks.push(chunk))
    doc.on('end', () => resolve(Buffer.concat(chunks)))
    doc.on('error', reject)

    addWatermark(doc)

    // Header
    doc.y = STYLES.spacing.sectionTop
    doc
      .fillColor(STYLES.colors.primaryText)
      .fontSize(STYLES.sizes.h1)
      .font(STYLES.fonts.header)
      .text('Proof Pack Index', { align: 'left' })

    // Orange underline
    const underlineY = doc.y - 4
    doc
      .strokeColor(STYLES.colors.accent)
      .lineWidth(2)
      .moveTo(STYLES.spacing.pageMargin, underlineY)
      .lineTo(STYLES.spacing.pageMargin + 160, underlineY)
      .stroke()

    doc.moveDown(0.5)

    // Pack Summary
    doc
      .fillColor(STYLES.colors.secondaryText)
      .fontSize(STYLES.sizes.body)
      .font(STYLES.fonts.body)
      .text(`Pack ID: ${meta.packId}`, { align: 'left' })
      .text(`Organization: ${meta.organizationName}`, { align: 'left' })
      .text(`Generated: ${meta.generatedAt}`, { align: 'left' })
      .text(`Generated By: ${meta.generatedBy} (${meta.generatedByRole})`, { align: 'left' })
      .text(`Time Range: ${meta.timeRange}`, { align: 'left' })

    doc.moveDown(1)

    // Counts
    doc
      .fillColor(STYLES.colors.primaryText)
      .fontSize(STYLES.sizes.h3)
      .font(STYLES.fonts.header)
      .text('Contents Summary', { align: 'left' })

    doc.moveDown(0.3)
    doc
      .fillColor(STYLES.colors.secondaryText)
      .fontSize(STYLES.sizes.body)
      .font(STYLES.fonts.body)
      .text(`Ledger Events: ${manifest.counts?.ledger_events || 0}`, { align: 'left' })
      .text(`Controls: ${manifest.counts?.controls || 0}`, { align: 'left' })
      .text(`Attestations: ${manifest.counts?.attestations || 0}`, { align: 'left' })

    doc.moveDown(1)

    // Files in Pack
    doc
      .fillColor(STYLES.colors.primaryText)
      .fontSize(STYLES.sizes.h3)
      .font(STYLES.fonts.header)
      .text('Files in Pack', { align: 'left' })

    doc.moveDown(0.5)

    // File list table
    const tableTop = doc.y
    const colWidths = [150, 80, 100]
    const headers = ['File Name', 'Size (bytes)', 'SHA-256 Hash']
    
    doc.fontSize(9).font(STYLES.fonts.header).fillColor(STYLES.colors.primaryText)
    let x = STYLES.spacing.pageMargin
    headers.forEach((header, i) => {
      doc.text(header, x, tableTop, { width: colWidths[i], align: 'left' })
      x += colWidths[i] + 10
    })

    // File rows
    doc.fontSize(8).font(STYLES.fonts.body).fillColor(STYLES.colors.secondaryText)
    let y = tableTop + 20
    
    if (manifest.files && Array.isArray(manifest.files)) {
      manifest.files.forEach((file: any) => {
        if (y > doc.page.height - 100) {
          doc.addPage()
          addWatermark(doc)
          y = STYLES.spacing.sectionTop
        }
        
        x = STYLES.spacing.pageMargin
        const row = [
          file.name || 'Unknown',
          file.bytes?.toLocaleString() || '0',
          file.sha256 ? file.sha256.substring(0, 32) + '...' : 'N/A',
        ]
        
        row.forEach((cell, i) => {
          doc.text(String(cell), x, y, { width: colWidths[i], align: 'left' })
          x += colWidths[i] + 10
        })
        
        y += 15
      })
    }

    doc.moveDown(1)

    // Filters
    if (manifest.filters) {
      doc
        .fillColor(STYLES.colors.primaryText)
        .fontSize(STYLES.sizes.h3)
        .font(STYLES.fonts.header)
        .text('Applied Filters', { align: 'left' })

      doc.moveDown(0.3)
      doc
        .fillColor(STYLES.colors.secondaryText)
        .fontSize(STYLES.sizes.body)
        .font(STYLES.fonts.body)

      if (manifest.filters.time_range) {
        doc.text(`Time Range: ${manifest.filters.time_range}`, { align: 'left' })
      }
      if (manifest.filters.job_id) {
        doc.text(`Job ID: ${manifest.filters.job_id}`, { align: 'left' })
      }
      if (manifest.filters.site_id) {
        doc.text(`Site ID: ${manifest.filters.site_id}`, { align: 'left' })
      }
      if (manifest.filters.category) {
        doc.text(`Category: ${manifest.filters.category}`, { align: 'left' })
      }
    }

    doc.end()
  })
}
