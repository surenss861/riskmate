import PDFDocument from 'pdfkit'
import type PDFKit from 'pdfkit'
import { STYLES } from './styles'
import { addWatermark } from './helpers'
import { sanitizeText, safeTextForPdf } from './normalize'

interface HeaderOptions {
  title: string
  packId?: string
  organizationName?: string
  generatedBy?: string
  generatedByRole?: string
  generatedAt?: string
  timeRange?: string
}

interface FooterOptions {
  pageNumber: number
  totalPages?: number
  packId?: string
}

interface KPIRow {
  label: string
  value: string | number
  highlight?: boolean
}

interface TableColumn {
  header: string
  width: number
  align?: 'left' | 'center' | 'right'
}

interface TableOptions {
  columns: TableColumn[]
  rows: any[][]
  zebraStriping?: boolean
  rowHeight?: number
  fontSize?: number
}

/**
 * Shared PDF theme for all proof pack PDFs
 */

// Draw consistent header with RiskMate branding
export function drawHeader(doc: PDFKit.PDFDocument, options: HeaderOptions): void {
  const margin = STYLES.spacing.pageMargin
  doc.y = margin

  // Title with orange accent underline (sanitize to prevent control characters)
  doc
    .fillColor(STYLES.colors.primaryText)
    .fontSize(STYLES.sizes.h1)
    .font(STYLES.fonts.header)
    .text(safeTextForPdf(options.title, 'Header title'), margin, margin, { align: 'left' })

  const underlineY = doc.y - 4
  doc
    .strokeColor(STYLES.colors.accent)
    .lineWidth(2)
    .moveTo(margin, underlineY)
    .lineTo(margin + 200, underlineY)
    .stroke()

  doc.moveDown(0.5)

  // Metadata block (compact, organized)
  doc
    .fillColor(STYLES.colors.secondaryText)
    .fontSize(STYLES.sizes.caption)
    .font(STYLES.fonts.body)

  if (options.packId) {
    doc.text(safeTextForPdf(`Pack ID: ${options.packId}`, 'Header packId'), { align: 'left' })
  }
  if (options.organizationName) {
    doc.text(safeTextForPdf(`Organization: ${options.organizationName}`, 'Header organizationName'), { align: 'left' })
  }
  if (options.generatedBy && options.generatedByRole) {
    doc.text(safeTextForPdf(`Generated By: ${options.generatedBy} (${options.generatedByRole})`, 'Header generatedBy'), { align: 'left' })
  }
  if (options.generatedAt) {
    doc.text(safeTextForPdf(`Generated: ${new Date(options.generatedAt).toLocaleString()}`, 'Header generatedAt'), { align: 'left' })
  }
  if (options.timeRange) {
    doc.text(safeTextForPdf(`Time Range: ${options.timeRange}`, 'Header timeRange'), { align: 'left' })
  }

  doc.moveDown(1)
}

// Draw footer with page numbers
export function drawFooter(doc: PDFKit.PDFDocument, options: FooterOptions): void {
  const pageHeight = doc.page.height
  const margin = STYLES.spacing.pageMargin

  doc
    .fillColor(STYLES.colors.secondaryText)
    .fontSize(STYLES.sizes.caption)
    .font(STYLES.fonts.body)
    .text(
      safeTextForPdf(
        options.totalPages
          ? `Page ${options.pageNumber} of ${options.totalPages}`
          : `Page ${options.pageNumber}`,
        'Footer page number'
      ),
      margin,
      pageHeight - 40,
      { align: 'left' }
    )

  if (options.packId) {
    doc.text(
      safeTextForPdf(`Pack ID: ${options.packId}`, 'Footer packId'),
      doc.page.width - margin,
      pageHeight - 40,
      { align: 'right' }
    )
  }
}

// Draw section title with consistent styling
export function drawSectionTitle(doc: PDFKit.PDFDocument, text: string): void {
  doc.moveDown(0.8)
  doc
    .fillColor(STYLES.colors.primaryText)
    .fontSize(STYLES.sizes.h3)
    .font(STYLES.fonts.header)
    .text(safeTextForPdf(text, 'Section title'), { align: 'left' })

  // Subtle divider line
  const dividerY = doc.y - 4
  doc
    .strokeColor(STYLES.colors.divider)
    .lineWidth(0.5)
    .moveTo(STYLES.spacing.pageMargin, dividerY)
    .lineTo(doc.page.width - STYLES.spacing.pageMargin, dividerY)
    .stroke()

  doc.moveDown(0.5)
}

// Draw KPI row (summary stats as tiles)
export function drawKpiRow(doc: PDFKit.PDFDocument, stats: KPIRow[]): void {
  const margin = STYLES.spacing.pageMargin
  const pageWidth = doc.page.width
  const availableWidth = pageWidth - (margin * 2)
  const tileWidth = availableWidth / stats.length
  const tileHeight = 40
  const startY = doc.y

  stats.forEach((stat, index) => {
    const x = margin + (tileWidth * index)

    // Tile background
    doc
      .rect(x, startY, tileWidth - 8, tileHeight)
      .fillColor(stat.highlight ? STYLES.colors.accentLight : STYLES.colors.lightGrayBg)
      .fill()
      .strokeColor(STYLES.colors.borderGray)
      .lineWidth(0.5)
      .stroke()

    // Label (sanitize to prevent control characters)
    doc
      .fillColor(STYLES.colors.secondaryText)
      .fontSize(STYLES.sizes.caption)
      .font(STYLES.fonts.body)
      .text(safeTextForPdf(stat.label, `KPI label: ${stat.label}`), x + 8, startY + 6, { width: tileWidth - 16, align: 'left' })

    // Value (sanitize to prevent control characters - especially important for string values)
    const valueText = typeof stat.value === 'string' ? safeTextForPdf(stat.value, `KPI value: ${stat.label}`) : String(stat.value)
    doc
      .fillColor(stat.highlight ? STYLES.colors.accent : STYLES.colors.primaryText)
      .fontSize(STYLES.sizes.body)
      .font(STYLES.fonts.header)
      .text(valueText, x + 8, startY + 20, { width: tileWidth - 16, align: 'left' })
  })

  doc.y = startY + tileHeight + 12
}

// Draw table with proper pagination, wrapping, and styling
/**
 * Truncate text to fit within a given width, adding ellipsis if needed
 * Uses binary search to find the maximum text length that fits
 */
function truncateToWidth(
  doc: PDFKit.PDFDocument,
  text: string,
  width: number,
  opts: { font: string; fontSize: number }
): string {
  const clean = safeTextForPdf(String(text ?? ''), 'truncateToWidth')
  doc.font(opts.font).fontSize(opts.fontSize)

  if (doc.widthOfString(clean) <= width) return clean
  const ell = 'â€¦'
  if (doc.widthOfString(ell) > width) return '' // width too tiny

  // Binary search best fit
  let lo = 0
  let hi = clean.length
  while (lo < hi) {
    const mid = Math.ceil((lo + hi) / 2)
    const candidate = clean.slice(0, mid) + ell
    if (doc.widthOfString(candidate) <= width) lo = mid
    else hi = mid - 1
  }
  return clean.slice(0, lo) + ell
}

export function drawTable(
  doc: PDFKit.PDFDocument,
  options: TableOptions
): void {
  const margin = STYLES.spacing.pageMargin
  const pageWidth = doc.page.width
  const pageHeight = doc.page.height
  const rowHeight = options.rowHeight || 20
  const fontSize = options.fontSize || 8
  const zebraStriping = options.zebraStriping !== false

  // CRITICAL FIX: Account for column gaps in width normalization
  const columnGap = 4
  const colCount = options.columns.length
  const availableWidth = pageWidth - (margin * 2)
  const availableForColumns = availableWidth - columnGap * Math.max(0, colCount - 1)

  let currentY = doc.y
  let isFirstPage = true
  let rowIndex = 0

  // Calculate column widths (normalize to available width *minus gaps*)
  const totalColumnWidth = options.columns.reduce((sum, col) => sum + col.width, 0)
  const scaleFactor = availableForColumns / totalColumnWidth
  const normalizedColumns = options.columns.map(col => ({
    ...col,
    width: col.width * scaleFactor,
  }))

  const drawTableHeader = (y: number) => {
    doc
      .fontSize(fontSize)
      .font(STYLES.fonts.header)
      .fillColor(STYLES.colors.primaryText)

    let x = margin
    normalizedColumns.forEach((col) => {
      // Truncate header text to fit width, prevent wrapping
      const headerText = truncateToWidth(doc, col.header, col.width, {
        font: STYLES.fonts.header,
        fontSize,
      })

      doc.text(headerText, x, y, {
        width: col.width,
        align: col.align || 'left',
        lineBreak: false, // Prevent line breaks inside cells
      })
      x += col.width + columnGap
    })

    // Header underline
    doc
      .strokeColor(STYLES.colors.borderGray)
      .lineWidth(1)
      .moveTo(margin, y + 15)
      .lineTo(pageWidth - margin, y + 15)
      .stroke()
  }

  const drawTableRow = (row: any[], y: number, isEven: boolean) => {
    // Zebra striping background
    if (zebraStriping && isEven) {
      doc
        .rect(margin, y - 2, availableWidth, rowHeight)
        .fillColor(STYLES.colors.lightGrayBg)
        .fill()
    }

    doc
      .fontSize(fontSize)
      .font(STYLES.fonts.body)
      .fillColor(STYLES.colors.primaryText)

    let x = margin
    normalizedColumns.forEach((col, colIndex) => {
      const cellValue = row[colIndex] ?? ''
      // CRITICAL: Truncate to width to prevent wrapping, use lineBreak: false
      const cellText = truncateToWidth(doc, cellValue, col.width, {
        font: STYLES.fonts.body,
        fontSize,
      })

      doc.text(cellText, x, y, {
        width: col.width,
        align: col.align || 'left',
        lineBreak: false, // Prevent line breaks inside cells
      })
      x += col.width + columnGap
    })
  }

  // Draw header on first page
  if (options.rows.length > 0) {
    drawTableHeader(currentY)
    currentY += rowHeight + 8
  }

  // Draw rows with pagination
  options.rows.forEach((row, index) => {
    // Check if we need a new page
    if (currentY + rowHeight > pageHeight - 60) {
      // New page (don't add footer here - finalizePdf handles all footers)
      doc.addPage()
      addWatermark(doc)
      currentY = margin + 40

      // Redraw header on new page
      drawTableHeader(currentY)
      currentY += rowHeight + 8
      isFirstPage = false
    }

    const isEven = rowIndex % 2 === 0
    drawTableRow(row, currentY, isEven)
    currentY += rowHeight
    rowIndex++
  })

  doc.y = currentY + 12
}

// Draw empty state card
export function drawEmptyState(
  doc: PDFKit.PDFDocument,
  options: {
    title: string
    message: string
    filters?: Record<string, any>
    actionHint?: string
  }
): void {
  const margin = STYLES.spacing.pageMargin
  const pageWidth = doc.page.width
  const cardWidth = pageWidth - (margin * 2)
  const cardHeight = 120
  const cardY = doc.y

  // Card background
  doc
    .rect(margin, cardY, cardWidth, cardHeight)
    .fillColor(STYLES.colors.cardBg)
    .fill()
    .strokeColor(STYLES.colors.borderGray)
    .lineWidth(1)
    .stroke()

  // Title (sanitize to prevent control characters)
  doc
    .fillColor(STYLES.colors.primaryText)
    .fontSize(STYLES.sizes.h3)
    .font(STYLES.fonts.header)
    .text(safeTextForPdf(options.title, 'Empty state title'), margin + 16, cardY + 16, { align: 'left' })

  // Message (sanitize to prevent control characters)
  doc
    .fillColor(STYLES.colors.secondaryText)
    .fontSize(STYLES.sizes.body)
    .font(STYLES.fonts.body)
    .text(safeTextForPdf(options.message, 'Empty state message'), margin + 16, cardY + 40, {
      width: cardWidth - 32,
      align: 'left',
    })

  // Filters (if provided)
  if (options.filters && Object.keys(options.filters).length > 0) {
    const filterText = Object.entries(options.filters)
      .filter(([_, v]) => v !== null && v !== undefined && v !== '')
      .map(([k, v]) => `${k}: ${v}`)
      .join(', ')

    if (filterText) {
      doc
        .fontSize(STYLES.sizes.caption)
        .text(safeTextForPdf(`Applied filters: ${filterText}`, 'Empty state filters'), margin + 16, cardY + 70, {
          width: cardWidth - 32,
          align: 'left',
        })
    }
  }

  // Action hint
  if (options.actionHint) {
    doc
      .fillColor(STYLES.colors.accent)
      .fontSize(STYLES.sizes.caption)
      .font(STYLES.fonts.body)
      .text(safeTextForPdf(options.actionHint, 'Empty state actionHint'), margin + 16, cardY + 90, {
        width: cardWidth - 32,
        align: 'left',
      })
  }

  doc.y = cardY + cardHeight + 20
}

// Format hash for display (short version)
export function formatHashShort(hash: string, length: number = 16): string {
  if (!hash || hash.length < length) return hash
  return `${hash.substring(0, length)}...${hash.substring(hash.length - 8)}`
}

// Initialize page with watermark and header space
export function initPage(doc: PDFKit.PDFDocument): void {
  addWatermark(doc)
  doc.y = STYLES.spacing.sectionTop
}

/**
 * Finalize PDF with proper page buffering and footers
 * PDFDocument must be created with bufferPages: true option
 */
export function finalizePdf(
  doc: PDFKit.PDFDocument,
  meta: { packId: string }
): void {
  // Get the buffered page range (may not start at 0)
  const range = (doc as any).bufferedPageRange()
  
  if (!range || range.count === 0) {
    // No pages buffered, nothing to finalize
    return
  }

  // Draw footer on each page using correct page indices
  // Never assume page 0 exists - always use range.start
  for (let i = range.start; i < range.start + range.count; i++) {
    doc.switchToPage(i)
    drawFooter(doc, {
      pageNumber: i - range.start + 1, // Page number (1-based, relative to range)
      totalPages: range.count,
      packId: meta.packId,
    })
  }

  // Flush buffered pages
  ;(doc as any).flushPages()
}
