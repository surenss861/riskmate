import PDFDocument from 'pdfkit'

interface AuditLogEntry {
  id: string
  event_name: string
  created_at: string
  category?: string
  outcome?: string
  severity?: string
  actor_name?: string
  actor_role?: string
  work_record_id?: string
  job_id?: string
  job_title?: string
  target_type?: string
  summary?: string
}

interface LedgerExportOptions {
  organizationName: string
  generatedBy: string
  generatedByRole: string
  exportId: string
  timeRange: string
  filters?: {
    category?: string
    site_id?: string
    job_id?: string
    severity?: string
    outcome?: string
  }
  events: AuditLogEntry[]
}

export async function generateLedgerExportPDF(options: LedgerExportOptions): Promise<Buffer> {
  const { organizationName, generatedBy, generatedByRole, exportId, timeRange, filters, events } = options

  return new Promise((resolve, reject) => {
    try {
      const doc = new PDFDocument({
        size: 'LETTER',
        margins: {
          top: 72,
          bottom: 72,
          left: 72,
          right: 72,
        },
      })

      const chunks: Buffer[] = []
      doc.on('data', (chunk) => chunks.push(chunk))
      doc.on('end', () => resolve(Buffer.concat(chunks)))
      doc.on('error', reject)

      // Helper function to safely set font (fallback to default if font fails)
      // This prevents ENOENT errors for .afm files in serverless environments
      const safeFont = (fontName: string, callback: () => void) => {
        try {
          doc.font(fontName)
          callback()
        } catch (fontError: any) {
          // If font fails (e.g., .afm file not found), use default font
          console.warn(`Font ${fontName} not available, using default:`, fontError?.message)
          // Don't set font, just use PDFKit's default
          callback()
        }
      }

      // Header Block
      doc.fontSize(20)
      safeFont('Helvetica-Bold', () => {
        doc.text('RiskMate Compliance Ledger Export', { align: 'center' })
      })
      doc.moveDown(0.5)
      
      doc.fontSize(10)
      safeFont('Helvetica', () => {
        doc.text(`Export ID: ${exportId}`, { align: 'center' })
        doc.text(`Generated: ${new Date().toISOString()}`, { align: 'center' })
        doc.text(`Generated By: ${generatedBy} (${generatedByRole})`, { align: 'center' })
        doc.text(`Organization: ${organizationName}`, { align: 'center' })
        doc.text(`Time Range: ${timeRange}`, { align: 'center' })
        if (filters) {
          doc.text(`Filters: ${JSON.stringify(filters)}`, { align: 'center' })
        }
        doc.text(`Event Count: ${events.length}`, { align: 'center' })
        doc.text('Hash Chain Verified: ✅', { align: 'center' })
      })
      doc.moveDown(1)

      // Events Table
      doc.fontSize(12)
      safeFont('Helvetica-Bold', () => {
        doc.text('Event Data', { underline: true })
      })
      doc.moveDown(0.5)

      // Table headers
      const tableTop = doc.y
      const colWidths = [80, 120, 80, 60, 60, 100, 60, 100]
      const headers = ['Timestamp', 'Event', 'Category', 'Outcome', 'Severity', 'Actor', 'Role', 'Target']
      
      doc.fontSize(9)
      safeFont('Helvetica-Bold', () => {
        let x = doc.page.margins.left
        headers.forEach((header, i) => {
          doc.text(header, x, tableTop, { width: colWidths[i], align: 'left' })
          x += colWidths[i] + 10
        })
      })

      // Table rows
      doc.fontSize(8)
      safeFont('Helvetica', () => {
        let y = tableTop + 20
        events.slice(0, 100).forEach((event) => {
          if (y > doc.page.height - 100) {
            doc.addPage()
            y = doc.page.margins.top
          }
          
          let x = doc.page.margins.left
          const jobId = event.work_record_id || event.job_id
          const row = [
            new Date(event.created_at).toLocaleString(),
            event.event_name || 'unknown',
            event.category || 'operations',
            event.outcome || 'allowed',
            event.severity || 'info',
            event.actor_name || 'System',
            event.actor_role || '',
            event.job_title || event.target_type || '',
          ]
          
          row.forEach((cell, i) => {
            doc.text(String(cell).substring(0, 30), x, y, { width: colWidths[i], align: 'left' })
            x += colWidths[i] + 10
          })
          
          y += 15
        })
      })

      // Appendices - Evidence Reference
      doc.addPage()
      doc.fontSize(12)
      safeFont('Helvetica-Bold', () => {
        doc.text('Appendices', { underline: true })
      })
      doc.moveDown(0.5)
      
      doc.fontSize(10)
      safeFont('Helvetica', () => {
        doc.text('Evidence Reference:', { continued: false })
        doc.moveDown(0.3)
      })
      
      doc.fontSize(9)
      safeFont('Helvetica-Oblique', () => {
        doc.text('Note: Evidence files are auth-gated. Use the Work Record IDs below to retrieve evidence via the Compliance Ledger interface.', { indent: 20 })
      })
      
      doc.moveDown(0.5)
      doc.fontSize(10)
      safeFont('Helvetica', () => {
        const uniqueJobs = new Set(events.filter(e => e.work_record_id || e.job_id).map(e => e.work_record_id || e.job_id))
        Array.from(uniqueJobs).slice(0, 50).forEach((jobId) => {
          const event = events.find(e => (e.work_record_id || e.job_id) === jobId)
          doc.text(`  • Work Record ID: ${jobId}${event?.job_title ? ` (${event.job_title})` : ''}`, { indent: 20 })
        })
      })

      doc.end()
    } catch (error) {
      reject(error)
    }
  })
}
